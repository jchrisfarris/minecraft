AWSTemplateFormatVersion: '2010-09-09'
Description: Deploy a Minecraft Server & Alexa Skill

Parameters:

  pBucketName:
    Description: S3 Bucket with Backups & logs
    Type: String

  pKeyName:
    Description: KeyName for instances
    Type: AWS::EC2::KeyPair::KeyName
    Default: '-'

  pHostedZoneId:
    Description: Hosted Zone ID to register the public IP
    Type: AWS::Route53::HostedZone::Id
    Default: '-'

  pAdminIpAddress:
    Description: This IP Address is allowed to ssh to the server instance
    Type: String

  pServiceFQDN:
    Description: FQDN of the instance Host. domain name must match the Hosted Zone ID
    Type: String
    Default: ''

  pBedtimeCron:
    Description: Cron Expression in GMT
    Type: String
    Default: cron(0 01 * * ? *)

  pServerInitialize:
    Description: Should the server create a new server, or load the most recent server from S3
    Type: String
    AllowedValues:
      - CreateServer
      - RestoreServer

  pServerName:
    Description: Internal name of the minecraft server (used by msm)
    Type: String
    Default: minecraft

  InstanceType:
    Description: Instance Type
    Type: String
    Default: t3.small

  ImageId:
    Description: AMI ID for AmazonLinux2 in the Region you're deploying in
    Type: AWS::EC2::Image::Id
    Default: ami-02da3a138888ced85 # Amazon Linux 2 in us-east-1

Resources:
  #
  # Server Instance itself
  #

  ServerInstance:
    Type: AWS::EC2::Instance
    CreationPolicy:
      ResourceSignal:
        Count: '1'
        Timeout: PT15M
    Metadata:
      AWS::CloudFormation::Init:
        # Docs: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-init.html
        configSets:
          CreateServer:
            - "InstallMinecraft"
            - "CreateServer"
          RestoreServer:
            - "InstallMinecraft"
            - "RestoreServer"
        InstallMinecraft:
          commands:
            install:
              command: "curl https://raw.githubusercontent.com/jchrisfarris/minecraft/master/scripts/install.sh | bash"
              cwd: "/home/ec2-user"
              ignoreErrors: "false"
          files:
            /etc/minecraft.conf:
              content: !Sub |
                STACKNAME=${AWS::StackName}
                SERVERHOSTNAME=${pServiceFQDN}
                BUCKET=${pBucketName}
              mode: "000644"
              owner: "root"
              group: "root"
          services:
            sysvinit:
              msm:
                enabled: "true"
                ensureRunning: "true"
        CreateServer:
          commands:
            install:
              command: "/home/ec2-user/scripts/new_world.sh"
              cwd: "/home/ec2-user"
              ignoreErrors: "false"
        RestoreServer:
          commands:
            install:
              command: "/home/ec2-user/scripts/restore.sh"
              cwd: "/home/ec2-user"
              ignoreErrors: "false"
    Properties:
      ImageId: !Ref ImageId
      InstanceType: !Ref InstanceType
      SecurityGroups:
        - !Ref ServerSecurityGroup
      KeyName: !Ref 'pKeyName'
      IamInstanceProfile: !Ref ServerInstanceProfile
      Tags:
      - Key: Name
        Value:
          Ref: AWS::StackName
      UserData:
        Fn::Base64:
          !Sub |
              #!/bin/bash -x
              /opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource ServerInstance --configsets ${pServerInitialize} --region ${AWS::Region}
              /opt/aws/bin/cfn-signal -e 0 --region ${AWS::Region} --stack ${AWS::StackName} --resource ServerInstance

  ServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow external Addresses to SSH to Instance Host
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: '22'
          ToPort: '22'
          CidrIp: !Ref 'pAdminIpAddress'
          Description: Remote Admin
        - IpProtocol: tcp
          FromPort: '25565'
          ToPort: '25565'
          CidrIp: !Ref 'pAdminIpAddress'
          Description: Minecraft
      Tags:
        - Key: Name
          Value: MinecraftServerSecurityGroup

  ServerInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref ServerInstanceRole

  DNSRecord:
    # We need this to create the DNS record when the instance is first created.
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref pHostedZoneId
      Name: !Sub "${pServiceFQDN}"
      ResourceRecords:
        - !GetAtt ServerInstance.PublicIp
      TTL: 30
      Type: A

  #
  # IAM Roles
  #
  ServerInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - ec2.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonEC2RoleforSSM
      Policies:
      - PolicyName: CloudWatch
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Action:
            - cloudwatch:*
            Effect: Allow
            Resource: '*'
      - PolicyName: EC2DescribeInstances
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Action:
            - ec2:Describe*
            Effect: Allow
            Resource: '*'
      - PolicyName: logs
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Resource: '*'
            Action:
            - logs:*
            Effect: Allow
      - PolicyName: Route53
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Resource: !Sub arn:aws:route53:::hostedzone/${pHostedZoneId}
            Action:
            - Route53:ChangeResourceRecordSets
            Effect: Allow
      - PolicyName: S3Access
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Resource:
            - !Sub arn:aws:s3:::${pBucketName}
            - !Sub arn:aws:s3:::${pBucketName}/*
            Action:
            - s3:*
            Effect: Allow

  LambdaInvocationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - events.amazonaws.com
            - sns.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: /
      Policies:
      - PolicyName: ExecuteLambda
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Action:
            - lambda:InvokeFunction
            Effect: Allow
            Resource:
              - !GetAtt DNSUpdateLambda.Arn
              - !GetAtt StartStopServerLambda.Arn

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: /
      Policies:
      - PolicyName: CloudWatch
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Action:
            - cloudwatch:*
            Effect: Allow
            Resource: '*'
      - PolicyName: EC2DescribeInstances
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Action:
            - ec2:Describe*
            Effect: Allow
            Resource: '*'
      - PolicyName: logs
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Resource: '*'
            Action:
            - logs:*
            Effect: Allow
      - PolicyName: Route53
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Resource: !Sub arn:aws:route53:::hostedzone/${pHostedZoneId}
            Action:
            - Route53:ChangeResourceRecordSets
            Effect: Allow
      - PolicyName: StartStopInstances
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Action:
            - ec2:StopInstances
            - ec2:StartInstances
            Effect: Allow
            Resource:
              - !Sub arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:instance/${ServerInstance}

  #
  # Automatic Server Shutdown at bedtime
  #
  StartStopServerLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Update the DNS entry when the Minecraft server is started
      Runtime: python3.7
      Handler: index.lambda_handler
      Timeout: '80'
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError
          import sys
          import os

          import logging
          logger = logging.getLogger()
          logger.setLevel(logging.DEBUG)
          # Quiet Boto3
          logging.getLogger('botocore').setLevel(logging.WARNING)
          logging.getLogger('boto3').setLevel(logging.WARNING)

          def lambda_handler(event, context):
              # logger.debug("Received event: " + json.dumps(event, sort_keys=True))
              # message = json.loads(event['Records'][0]['Sns']['Message'])
              message = event
              logger.info("Received message: " + json.dumps(message, sort_keys=True))

              client = boto3.client('ec2')
              instance_id = os.environ['INSTANCE_ID']

              if message['command'] == "stop":
                logger.info(f"Stopping Instance {os.environ['INSTANCE_ID']}")
                response = client.stop_instances(InstanceIds=[instance_id])
                logger.debug(response)
              elif message['command'] == "start":
                logger.info(f"Starting Instance {os.environ['INSTANCE_ID']}")
                response = client.start_instances(InstanceIds=[instance_id])
                logger.debug(response)
              else:
                logger.error(f"Invalid Command {message['command']}")
          ### End Of Function ###
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          HOSTED_ZONE: !Ref pHostedZoneId
          SERVER_FQDN: !Sub "${AWS::StackName}.{pServiceFQDN}"
          INSTANCE_ID: !Ref ServerInstance

  ShutdownServerRule:
    Type: "AWS::Events::Rule"
    Properties:
      Description: "Shutdown Minecraft Server at bedtime"
      ScheduleExpression: !Ref pBedtimeCron
      Targets:
      - Arn: !GetAtt StartStopServerLambda.Arn
        Id: TargetFunctionV1
        Input:  !Sub |
          {"command": "stop"}

  ShutdownServerLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt StartStopServerLambda.Arn
      Principal: events.amazonaws.com
      SourceArn: !GetAtt ShutdownServerRule.Arn
      Action: lambda:invokeFunction

  #
  # Resources to set DNS on Instance Start
  #
  DNSUpdateLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Update the DNS entry when the Minecraft server is started or stopped
      Runtime: python3.7
      Handler: index.lambda_handler
      Timeout: '80'
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError
          import sys
          import os

          import logging
          logger = logging.getLogger()
          logger.setLevel(logging.DEBUG)
          # Quiet Boto3
          logging.getLogger('botocore').setLevel(logging.WARNING)
          logging.getLogger('boto3').setLevel(logging.WARNING)

          def lambda_handler(event, context):
              logger.debug("Received event: " + json.dumps(event, sort_keys=True))

              ec2_client = boto3.client('ec2')
              route53_client = boto3.client('route53')
              instance_id = os.environ['INSTANCE_ID']

              try:
                if event['detail']['instance-id'] != instance_id:
                  return(event) # Nothing to Do here

                if event['detail']['state'] == "running" and :
                  instance_deets = ec2_client.describe_instances(InstanceIds=[instance_id])['Reservations']['Instances'][0]
                  if 'PublicIpAddress' not in instance_deets:
                    raise Exception("No Public IP for Instance")
                  else:
                    response = route53_client.change_resource_record_sets(
                      HostedZoneId=os.environ['HOSTED_ZONE'],
                      ChangeBatch={
                        'Changes': [
                          {
                            'Action':'UPSERT',
                            'ResourceRecordSet': {
                              'Name': os.environ['SERVER_FQDN'],
                              'Type': 'A',
                              'TTL': 30,
                              'ResourceRecords': [{'Value': instance_deets['PublicIpAddress']}]
                            }
                          }
                        ]
                      }
                    )
                    logger.info(response)
                    return(event)

                if event['detail']['state'] == "stopping":
                  instance_deets = ec2_client.describe_instances(InstanceIds=[instance_id])['Reservations']['Instances'][0]
                  if 'PublicIpAddress' not in instance_deets:
                    raise Exception("No Public IP for Instance")
                  else:
                    response = route53_client.change_resource_record_sets(
                      HostedZoneId=os.environ['HOSTED_ZONE'],
                      ChangeBatch={
                        'Changes': [
                          {
                            'Action':'DELETE',
                            'ResourceRecordSet': {
                              'Name': os.environ['SERVER_FQDN'],
                              'Type': 'A',
                              'TTL': 30,
                              'ResourceRecords': [{'Value': instance_deets['PublicIpAddress']}]
                            }
                          }
                        ]
                      }
                    )
                    logger.info(response)
                    return(event)


              except KeyError as e:
                logger.error(f"KeyError: {e}")
          ### End Of Function ###

      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          HOSTED_ZONE: !Ref pHostedZoneId
          SERVER_FQDN: !Sub "${pServiceFQDN}"
          INSTANCE_ID: !Ref ServerInstance

  Ec2StartStopRule:
    Type: AWS::Events::Rule
    Properties:
      Description: Send Instance State Change notifications to Slack (via Lambda)
      EventPattern:
        source:
        - aws.ec2
        detail-type:
        - EC2 Instance State-change Notification
      State: ENABLED
      RoleArn: !GetAtt LambdaInvocationRole.Arn
      Targets:
      - Arn: !GetAtt DNSUpdateLambda.Arn
        Id: TargetFunctionV1

  DNSUpdateLambdaPermissionEc2StartStopRule:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt DNSUpdateLambda.Arn
      Principal: events.amazonaws.com
      SourceArn: !GetAtt Ec2StartStopRule.Arn
      Action: lambda:invokeFunction


  #
  # SSM Commands
  #
  MSMCommandDocument:
    Type: "AWS::SSM::Document"
    Properties:
      DocumentType: Command
      Content:
        schemaVersion: "2.2"
        description: "executes an MSM command on a specific server"
        parameters:
          Server:
            type: "String"
            description: "Server Name"
            default: !Ref AWS::StackName
          Command:
            type: "String"
            description: "MSM Command and params to execute"
        mainSteps:
        - action: "aws:runShellScript"
          name: "msm"
          inputs:
            runCommand:
            - "echo \"`date` /bin/msm {{Server}} {{Command}}\" >> /tmp/msm_commands.log"
            - "tail -1 /tmp/msm_commands.log"
            workingDirectory: "/home/ec2-user"

  ExecScriptDocument:
    Type: "AWS::SSM::Document"
    Properties:
      DocumentType: Command
      Content:
        schemaVersion: "2.2"
        description: "executes a script on the minecraft instance"
        parameters:
          Command:
            type: "String"
            description: "Script and params to execute"
        mainSteps:
        - action: "aws:runShellScript"
          name: "msm"
          inputs:
            runCommand:
            - "echo \"`date` /home/ec2-user/scripts/{{Command}}\" >> /tmp/ssm_commands.log"
            - "tail -1 /tmp/ssm_commands.log"
            workingDirectory: "/home/ec2-user"


Outputs:
  STACKNAME:
    Value: !Ref 'AWS::StackName'
  SERVERHOSTNAME:
    Value: !Sub "${pServiceFQDN}"
  INSTANCEID:
    Value: !Ref ServerInstance
  MSMCOMMAND:
    Value: !Ref MSMCommandDocument
  EXECSCRIPT:
    Value: !Ref ExecScriptDocument
  BUCKET:
    Value: !Ref pBucketName
